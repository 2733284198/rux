{"name":"Rux","tagline":"⚡ Rux is an simple and fast web framework. support middleware, compatible http.Handler interface. 简单且快速的 Go web 框架，支持中间件，兼容 http.Handler 接口","body":"# Rux\r\n\r\n[![GitHub tag (latest SemVer)](https://img.shields.io/github/tag/gookit/rux)](https://github.com/gookit/rux)\r\n[![GoDoc](https://godoc.org/github.com/gookit/rux?status.svg)](https://pkg.go.dev/github.com/gookit/rux?tab=doc)\r\n[![Build Status](https://travis-ci.org/gookit/rux.svg?branch=master)](https://travis-ci.org/gookit/rux)\r\n[![Coverage Status](https://coveralls.io/repos/github/gookit/rux/badge.svg?branch=master)](https://coveralls.io/github/gookit/rux?branch=master)\r\n[![Go Report Card](https://goreportcard.com/badge/github.com/gookit/rux)](https://goreportcard.com/report/github.com/gookit/rux)\r\n\r\nSimple and fast web framework for build golang HTTP applications.\r\n\r\n> **[中文说明](README.zh-CN.md)**\r\n\r\n- Fast route match, support route group\r\n- Support route path params and named routing\r\n- Support cache recently accessed dynamic routes\r\n- Support route middleware, group middleware, global middleware\r\n- Support generic `http.Handler` interface middleware\r\n- Support static file access handle\r\n- Support add handlers for handle `NotFound` and `NotAllowed`\r\n\r\n## GoDoc\r\n\r\n- [godoc for github](https://pkg.go.dev/github.com/gookit/rux?tab=doc)\r\n\r\n## Quick start\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\nfunc main() {\r\n\tr := rux.New()\r\n\t\r\n\t// Static Assets\r\n\t// one file\r\n\tr.StaticFile(\"/site.js\", \"testdata/site.js\")\r\n\t// allow any files in the dir.\r\n\tr.StaticDir(\"/static\", \"testdata\")\r\n\t// file type limit\r\n\tr.StaticFiles(\"/assets\", \"testdata\", \"css|js\")\r\n\r\n\t// Add Routes:\r\n\t\r\n\tr.GET(\"/\", func(c *rux.Context) {\r\n\t\tc.Text(200, \"hello\")\r\n\t})\r\n\tr.GET(\"/hello/{name}\", func(c *rux.Context) {\r\n\t\tc.Text(200, \"hello \" + c.Param(\"name\"))\r\n\t})\r\n\tr.POST(\"/post\", func(c *rux.Context) {\r\n\t\tc.Text(200, \"hello\")\r\n\t})\r\n\tr.Group(\"/articles\", func() {\r\n\t\tr.GET(\"\", func(c *rux.Context) {\r\n\t\t\tc.Text(200, \"view list\")\r\n\t\t})\r\n\t\tr.POST(\"\", func(c *rux.Context) {\r\n\t\t\tc.Text(200, \"create ok\")\r\n\t\t})\r\n\t\tr.GET(`/{id:\\d+}`, func(c *rux.Context) {\r\n\t\t\tc.Text(200, \"view detail, id: \" + c.Param(\"id\"))\r\n\t\t})\r\n\t})\r\n\t\r\n\t// add multi method support for an route path\r\n\tr.Add(\"/post[/{id}]\", func(c *rux.Context) {\r\n\t\tif c.Param(\"id\") == \"\" {\r\n\t\t\t// do create post\r\n\t\t\tc.Text(200, \"created\")\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\tid := c.Params.Int(\"id\")\r\n\t\t// do update post\r\n\t\tc.Text(200, \"updated \" + fmt.Sprint(id))\r\n\t}, rux.POST, rux.PUT)\r\n\r\n\t// quick start\r\n\tr.Listen(\":8080\")\r\n\t// can also\r\n\t// http.ListenAndServe(\":8080\", r)\r\n}\r\n```\r\n\r\n## Use Middleware\r\n\r\nrux support use middleware, allow:\r\n\r\n- global middleware\r\n- group middleware\r\n- route middleware\r\n\r\n**Call priority**: `global middleware -> group middleware -> route middleware`\r\n\r\n### Example\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\nfunc main() {\r\n\tr := rux.New()\r\n\t\r\n\t// add global middleware\r\n\tr.Use(func(c *rux.Context) {\r\n\t    // do something ...\r\n\t})\r\n\t\r\n\t// add middleware for the route\r\n\troute := r.GET(\"/middle\", func(c *rux.Context) { // main handler\r\n\t\tc.WriteString(\"-O-\")\r\n\t}, func(c *rux.Context) { // middle 1\r\n        c.WriteString(\"a\")\r\n        c.Next() // Notice: call Next()\r\n        c.WriteString(\"A\")\r\n        // if call Abort(), will abort at the end of this middleware run\r\n        // c.Abort() \r\n    })\r\n\t\r\n\t// add more by Use()\r\n\troute.Use(func(c *rux.Context) { // middle 2\r\n\t\tc.WriteString(\"b\")\r\n\t\tc.Next()\r\n\t\tc.WriteString(\"B\")\r\n\t})\r\n\r\n\t// now, access the URI /middle\r\n\t// will output: ab-O-BA\r\n}\r\n```\r\n\r\n- **Call sequence**: `middle 1 -> middle 2 -> main handler -> middle 2 -> middle 1`\r\n- **Flow chart**:\r\n\r\n```text\r\n        +-----------------------------+\r\n        | middle 1                    |\r\n        |  +----------------------+   |\r\n        |  | middle 2             |   |\r\n start  |  |  +----------------+  |   | end\r\n------->|  |  |  main handler  |  |   |--->----\r\n        |  |  |________________|  |   |    \r\n        |  |______________________|   |  \r\n        |_____________________________|\r\n```\r\n\r\n> more please see [middleware_test.go](middleware_test.go) middleware tests\r\n\r\n## Use http.Handler\r\n\r\nrux is support generic `http.Handler` interface middleware\r\n\r\n> You can use `rux.WrapHTTPHandler()` convert `http.Handler` as `rux.HandlerFunc`\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"net/http\"\r\n\t\r\n\t\"github.com/gookit/rux\"\r\n\t// here we use gorilla/handlers, it provides some generic handlers.\r\n\t\"github.com/gorilla/handlers\"\r\n)\r\n\r\nfunc main() {\r\n\tr := rux.New()\r\n\t\r\n\t// create a simple generic http.Handler\r\n\th0 := http.HandlerFunc(func (w http.ResponseWriter, r *http.Request) {\r\n\t\tw.Header().Set(\"new-key\", \"val\")\r\n\t})\r\n\t\r\n\tr.Use(rux.WrapHTTPHandler(h0), rux.WrapHTTPHandler(handlers.ProxyHeaders()))\r\n\t\r\n\tr.GET(\"/\", func(c *rux.Context) {\r\n\t\tc.Text(200, \"hello\")\r\n\t})\r\n\t// add routes ...\r\n\t\r\n    // Wrap our server with our gzip handler to gzip compress all responses.\r\n    http.ListenAndServe(\":8000\", handlers.CompressHandler(r))\r\n}\r\n```\r\n\r\n## More Usage\r\n\r\n### Static Assets\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"net/http\"\r\n\t\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\nfunc main() {\r\n\tr := rux.New()\r\n\r\n\t// one file\r\n\tr.StaticFile(\"/site.js\", \"testdata/site.js\")\r\n\r\n\t// allow any files in the directory.\r\n\tr.StaticDir(\"/static\", \"testdata\")\r\n\r\n\t// file type limit in the directory\r\n\tr.StaticFiles(\"/assets\", \"testdata\", \"css|js\")\r\n}\r\n```\r\n\r\n### Name Route\r\n\r\nIn `rux`, you can add a named route, and you can get the corresponding route instance(`rux.Route`) from the router according to the name.\r\n\r\nExamples：\r\n\r\n```go\r\n\tr := rux.New()\r\n\t\r\n\t// Method 1\r\n\tmyRoute := rux.NewNamedRoute(\"name1\", \"/path4/some/{id}\", emptyHandler, \"GET\")\r\n\tr.AddRoute(myRoute)\r\n\r\n\t// Method 2\r\n\trux.AddNamed(\"name2\", \"/\", func(c *rux.Context) {\r\n\t\tc.Text(200, \"hello\")\r\n\t})\r\n\r\n\t// Method 3\r\n\tr.GET(\"/hi\", func(c *rux.Context) {\r\n\t\tc.Text(200, \"hello\")\r\n\t}).NamedTo(\"name3\", r)\r\n\t\r\n\t// get route by name\r\n\tmyRoute = r.GetRoute(\"name1\")\r\n```\r\n\r\n### Redirect\r\n\r\n```go\r\n\tr.GET(\"/\", func(c *rux.Context) {\r\n\t\tc.AbortThen().Redirect(\"/login\", 302)\r\n\t})\r\n    \r\n\t// Or\r\n\tr.GET(\"/\", func(c *rux.Context) {\r\n\t\tc.Redirect(\"/login\", 302)\r\n        c.Abort()\r\n\t})\r\n\r\n\tr.GET(\"/\", func(c *rux.Context) {\r\n        c.Back()\r\n        c.Abort()\r\n    })\r\n```\r\n\r\n### Multi Domains\r\n\r\n> code is refer from `julienschmidt/httprouter`\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\ntype HostSwitch map[string]http.Handler\r\n\r\n// Implement the ServeHTTP method on our new type\r\nfunc (hs HostSwitch) ServeHTTP(w http.ResponseWriter, r *http.Request) {\r\n\t// Check if a http.Handler is registered for the given host.\r\n\t// If yes, use it to handle the request.\r\n\tif router := hs[r.Host]; router != nil {\r\n\t\trouter.ServeHTTP(w, r)\r\n\t} else {\r\n\t\t// Handle host names for which no handler is registered\r\n\t\thttp.Error(w, \"Forbidden\", 403) // Or Redirect?\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\t// Initialize a router as usual\r\n\trouter := rux.New()\r\n\trouter.GET(\"/\", Index)\r\n\trouter.GET(\"/hello/{name}\", func(c *rux.Context) {})\r\n\r\n\t// Make a new HostSwitch and insert the router (our http handler)\r\n\t// for example.com and port 12345\r\n\ths := make(HostSwitch)\r\n\ths[\"example.com:12345\"] = router\r\n\r\n\t// Use the HostSwitch to listen and serve on port 12345\r\n\tlog.Fatal(http.ListenAndServe(\":12345\", hs))\r\n}\r\n```\r\n\r\n### RESETFul Style\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\ntype Product struct {\r\n}\r\n\r\n// Uses middlewares [optional]\r\nfunc (Product) Uses() map[string][]rux.HandlerFunc {\r\n\treturn map[string][]rux.HandlerFunc{\r\n\t\t// function name: handlers\r\n\t\t\"Delete\": []rux.HandlerFunc{\r\n\t\t\thandlers.HTTPBasicAuth(map[string]string{\"test\": \"123\"}),\r\n\t\t\thandlers.GenRequestID(),\r\n\t\t},\r\n\t}\r\n}\r\n\r\n// all products [optional]\r\nfunc (p *Product) Index(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\n// create product [optional]\r\nfunc (p *Product) Create(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\n// save new product [optional]\r\nfunc (p *Product) Store(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\n// show product with {id} [optional]\r\nfunc (p *Product) Show(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\n// edit product [optional]\r\nfunc (p *Product) Edit(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\n// save edited product [optional]\r\nfunc (p *Product) Update(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\n// delete product [optional]\r\nfunc (p *Product) Delete(c *rux.Context) {\r\n\t// balabala\r\n}\r\n\r\nfunc main() {\r\n\trouter := rux.New()\r\n\r\n\t// methods\tPath\tAction\tRoute Name\r\n    // GET\t/product\tindex\tproduct_index\r\n    // GET\t/product/create\tcreate\tproduct_create\r\n    // POST\t/product\tstore\tproduct_store\r\n    // GET\t/product/{id}\tshow\tproduct_show\r\n    // GET\t/product/{id}/edit\tedit\tproduct_edit\r\n    // PUT/PATCH\t/product/{id}\tupdate\tproduct_update\r\n    // DELETE\t/product/{id}\tdelete\tproduct_delete\r\n    // resetful style\r\n\trouter.Resource(\"/\", new(Product))\r\n\r\n\tlog.Fatal(http.ListenAndServe(\":12345\", router))\r\n}\r\n```\r\n\r\n### Controller Style\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\ntype News struct {\r\n}\r\n\r\nfunc (n *News) AddRoutes(g *rux.Router) {\r\n\tg.GET(\"/\", n.Index)\r\n\tg.POST(\"/\", n.Create)\r\n\tg.PUT(\"/\", n.Edit)\r\n}\r\n\r\nfunc (n *News) Index(c *rux.Context) {\r\n\t// Do something\r\n}\r\n\r\nfunc (n *News) Create(c *rux.Context) {\r\n\t// Do something\r\n}\r\n\r\nfunc (n *News) Edit(c *rux.Context) {\r\n\t// Do something\r\n}\r\n\r\nfunc main() {\r\n\trouter := rux.New()\r\n\r\n\t// controller style\r\n\trouter.Controller(\"/news\", new(News))\r\n\r\n\tlog.Fatal(http.ListenAndServe(\":12345\", router))\r\n}\r\n```\r\n\r\n### Build URL\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/gookit/rux\"\r\n)\r\n\r\nfunc main() {\r\n\t// Initialize a router as usual\r\n\trouter := rux.New()\r\n\trouter.GET(`/news/{category_id}/{new_id:\\d+}/detail`, func(c *rux.Context) {\r\n\t\tvar u = make(url.Values)\r\n        u.Add(\"username\", \"admin\")\r\n        u.Add(\"password\", \"12345\")\r\n\t\t\r\n\t\tb := rux.NewBuildRequestURL()\r\n        // b.Scheme(\"https\")\r\n        // b.Host(\"www.mytest.com\")\r\n        b.Queries(u)\r\n        b.Params(rux.M{\"{category_id}\": \"100\", \"{new_id}\": \"20\"})\r\n\t\t// b.Path(\"/dev\")\r\n        // println(b.Build().String())\r\n        \r\n        println(c.Router().BuildRequestURL(\"new_detail\", b).String())\r\n\t\t// result:  /news/100/20/detail?username=admin&password=12345\r\n\t\t// get current route name\r\n\t\tif c.MustGet(rux.CTXCurrentRouteName) == \"new_detail\" {\r\n            // post data etc....\r\n        }\r\n\t}).NamedTo(\"new_detail\", router)\r\n\r\n\t// Use the HostSwitch to listen and serve on port 12345\r\n\tlog.Fatal(http.ListenAndServe(\":12345\", router))\r\n}\r\n```\r\n\r\n## Help\r\n\r\n- lint\r\n\r\n```bash\r\ngolint ./...\r\n```\r\n\r\n- format check\r\n\r\n```bash\r\n# list error files\r\ngofmt -s -l ./\r\n# fix format and write to file\r\ngofmt -s -w some.go\r\n```\r\n\r\n- unit test\r\n\r\n```bash\r\ngo test -cover ./...\r\n```\r\n\r\n## Gookit Packages\r\n\r\n- [gookit/ini](https://github.com/gookit/ini) Go config management, use INI files\r\n- [gookit/rux](https://github.com/gookit/rux) Simple and fast request router for golang HTTP \r\n- [gookit/gcli](https://github.com/gookit/gcli) build CLI application, tool library, running CLI commands\r\n- [gookit/event](https://github.com/gookit/event) Lightweight event manager and dispatcher implements by Go\r\n- [gookit/cache](https://github.com/gookit/cache) Generic cache use and cache manager for golang. support File, Memory, Redis, Memcached.\r\n- [gookit/config](https://github.com/gookit/config) Go config management. support JSON, YAML, TOML, INI, HCL, ENV and Flags\r\n- [gookit/color](https://github.com/gookit/color) A command-line color library with true color support, universal API methods and Windows support\r\n- [gookit/filter](https://github.com/gookit/filter) Provide filtering, sanitizing, and conversion of golang data\r\n- [gookit/validate](https://github.com/gookit/validate) Use for data validation and filtering. support Map, Struct, Form data\r\n- [gookit/goutil](https://github.com/gookit/goutil) Some utils for the Go: string, array/slice, map, format, cli, env, filesystem, test and more\r\n- More please see https://github.com/gookit\r\n\r\n## See also\r\n\r\n- https://github.com/gin-gonic/gin\r\n- https://github.com/gorilla/mux\r\n- https://github.com/julienschmidt/httprouter\r\n- https://github.com/xialeistudio/go-dispatcher\r\n\r\n## License\r\n\r\n**[MIT](LICENSE)**\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}